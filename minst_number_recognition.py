# -*- coding: utf-8 -*-
"""6uzd best version

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b7633Y6PXIxC9NUivTgf3Yx6t1acMP7D
"""

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from tensorflow import keras
from tensorflow.keras.layers import Dense, Flatten, Input


mnist=tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()
#60000 mokymui, 10000 testavimui

# 15-os paveiksliukų atvaizadaviams iš mokymo aibės
plt.figure(figsize=(10,5)) # vieno paveiksliuko matmenys
for i in range(15):  # rodomų paveiksliukų kiekis
  plt.subplot(3,5,i+1) # paveiksliukų atvaizdavimas, eilučių ir stulpelių kiekis
  plt.xticks([]) # nustato žymas x ašyje
  plt.yticks([]) # nustato žymas y ašyje
  plt.imshow(x_train[i], cmap=plt.cm.binary) #cmap=plt.cm.binary - pilkos spalvos (Kitos spalvos: cmap=plt.cm.RdYlGn; cmap=plt.cm.Blues; cmap=plt.cm.autumn, cmap=plt.cm.Green ...  )
  #https://chrisalbon.com/code/python/basics/set_the_color_of_a_matplotlib/
plt.show()

#print(type(x_train[0])) # 0-io objekto klasė
#print(pk.shape) # objekto matmenys/dimensija
#print(y_train[0]) #0-io objekto klasė

# Įeinamų duomenų normalizacija, kad pikselio reikšmė būtų nuo 0 iki 1. Daliname iš didžiausio galima skaičiaus 255.
x_train=x_train/255
x_test=x_test/255

# Požymio reikšmės pakeitimas į vektorių, pvz. 2 -> {0,0,1,0,0,0,0,0,0,0}
y_train2=keras.utils.to_categorical(y_train,10)
y_test2=keras.utils.to_categorical(y_test,10)

#y_train2[0]

# Modelio kūrimas
model=keras.Sequential([
                        Input(shape=(28, 28, 1)), # (batch_size, height, width, channels)
                        Flatten(), # vaizdo matmenys ir 1 Baitas=1 pikselis, pilkos spalvos:  nuo 0 iki 255
                        Dense(100, activation='relu'), # paslėptas sluoksnis.
                        # Aktyvacijos funkcijos: 'sigmoid', 'tanh', 'elu', 'selu', 'relu'
                        #Dropout(0.4),
                        Dense(10, activation='softmax') # išėjimo sluoksis
])
#print(model.summary()) # išveda modelio aprašymą

# Param # - tai yra svoriai

# Automatiškai generuojamas neur. tinklas su pradiniais svoriaias
opt = keras.optimizers.RMSprop(learning_rate=0.1)
model.compile(optimizer=opt, #'sgd',
              # Gradientiai metodai: 'sgd', 'rmsprop', 'adam'
              loss='categorical_crossentropy',
              metrics=['accuracy'] )

# Neur. tinklo apmokymas
mokymo=model.fit(x_train, y_train2, batch_size=32, epochs=5, validation_split=0.2)
# batch - po kiekvienų iš 32 vaizdų koreaguosime svorius;
# epoch - ciklai
# validation - mokymo aibės išskaidymas į mokymo-patikrinimo

#mokymo proceso atvaizdavimas
mokymo.history
print(mokymo.history.keys())
mokymo.history.keys()

plt.plot(mokymo.history['accuracy'])
plt.plot(mokymo.history['val_accuracy'])
plt.legend(['mokymo', 'validavimo'])
plt.title('Modelio tikslumas')
plt.show()

plt.plot(mokymo.history['loss'])
#print(mokymo.history['val_loss'])
plt.plot(mokymo.history['val_loss'])
plt.title('Modelio loss funkcija')
plt.xlabel('epoch')
plt.ylabel('loss')
plt.legend(['mokymo', 'validavimo'], loc='upper left')
plt.show()

#ikeliam nauja pav

from PIL import Image
import numpy


img= Image.open("Sample7.png")
np_img = numpy.array(img)

print(np_img.shape)
# Import the necessary libraries
from PIL import Image
from numpy import asarray


# load the image and convert into

# PIL images into NumPy arrays
image= Image.open("Sample7b.png")
img = image.convert('L') # vaizdo konvertavimas į pilkos spalvos skalę
numpydata = asarray(img)

numpydata=numpydata/255
# <class 'numpy.ndarray'>
print(type(numpydata))

#  shape
print(numpydata.shape)

x=np.expand_dims(numpydata, axis=0) # išplėčia masyvą, (1, 28, 28)
spr=model.predict(x)
print(np.round(spr,3)) # išveda reikšmių vektorių
print(f"Skaičius: {np.argmax(spr)}") # išveda didžiausio skaičiaus eilės numerį, argumentą

plt.imshow(numpydata, cmap=plt.cm.binary)
plt.show()